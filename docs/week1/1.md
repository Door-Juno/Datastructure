# [3.5] WEEK 1 
### 01장. 자료구조와 알고리즘.pdf
### 1. 자료구조의 분류
* 선형자료구조 : 자료를 순서적으로 나열한다. (ex. List, Stack, Queue ... )
* 비선형자료구조 : 복잡한 연결 관계의 자료 표현이다. (ex. Tree, Graph ... )

### 2. 알고리즘의 조건
* 입력 : 0개 이상의 입력이 존재하여야 한다.
* 출력 : 1개 이상의 출력이 존재하여야 한다.
* 명백성 : 각 명령어의 의미는 명확하여야 한다.
* 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.
* 유효성 : 각 명령어들은 실행 가능한 연산이여야 한다. 
(0으로 나누기 같은건 유효성이 없음...)

### 3. 추상자료형 (ADT)
* 프로그래머가 추상적으로 정의한 자료형.
* 데이터나 연산이 무엇(What)인가를 정의하며 어떻게(How)구현할 것인지는 정의하지 않음.
* 구현의 영역에서는 각 언어에 의존하여 코드를 작성한다.

### 4. 알고리즘의 성능 분석
### 4-1. 실행 시간 측정
* 알고리즘의 실제 실행 시간을 측정한다.
* 알고리즘을 실제로 구현하여야 하며, 동일한 Hardware/Software 환경을 사용하여야한다.
(측정에 여러 제약이 있다는걸 알 수 있다.)
``` python 
import time

mybag = [] # ADT
start = time.time() # 시작 시간 측정
...
... # Algorithm
...
end = time.time() #종료 시간 측정
print("실행시간 = ", end - start ) # 알고리즘의 실행 시간
```

### 4-2. 복잡도 분석
* 직접 구현하지 않고 연산 횟수를 분석한다.
* 시간 복잡도 (TimeComplexity) : 연산의 횟수 분석
* 공간 복잡도 (SpaceComplexity) : 필요한 메모리 공간 분석
* 알고리즘의 연산 횟수를 대략적으로 계산하여 복잡도 함수(T(n))으로 표시한다.
* 이때 T(n)은 점근적 표기(asymptotic notation)을 이용한다.
* 점근적 표기 : 복잡도 함수를 최고차항 만을 계수 없이 취해 단순하게 표현하는 방법이다. -> n -> inf 이면 나머지 항의 효과는 거의 없는 것이나 마찬가지이다... 알고리즘의 증가 속도를 표현한다.

### 4-3. Big-O notation
* 점근적 상한 표기법이며 , 어떠한 경우에도 g(n)에 비례하는 시간 안에는 반드시 완료됨을 의미한다.
* O(g(n)) : 증가 속도가 C*g(n) >= T(n)을 만족하는 모든 T를 포함한다.

### 4-4. Big - Omega
* 점근적 하한 표기법이며, 어떠한 경우에도 g(n)에 비례하는 시간 이상이 소모된다.
* Omega(g(n)) : 증가속도가 C*g(n) <= T(n)을 만족하는 모든 T를 포함한다.

### 4-5. Big - Theta
* 상한이면서 하한이다. 
* Theta(g(n)) : 증가속도가 C1*g(n) <= T(n) <= C2*g(n) 을 만족하는 모든 T를 포함한다.
* 이때, Big-Theta 는 Big-O 와 Big-Omega의 공집합이다.

### 5. Case 분석
* 최선의 경우(Best case) : 수행 시간이 가장 빠른 경우
    * 가장 이상적인 상태. 의미 없는 경우가 많다.
* 평균의 경우 (Average case) : 수행 시간이 평균인 경우
    * 평균을 상정한 계산하기가 매우 어려움
* 최악의 경우 (Worst case) : 수행 시간이 가장 늦은 경우
    * 계산하기 쉬우며 가장 널리 사용된다. 보통 중요한 의미를 가진다.

### 5-1. Case 1. 순차 탐색
``` python 
def search(A,key) : 
    n = len(A)
    for i n range(n) : 
        if A[i] == key :
            return i
        return -1
```
* Best case : key가 맨 앞에 있는 경우
    T(n) = 1 -> O(1)
* Worst case : key 가 맨 마지막에 있거나 없는 경우
    T(n) = n -> O(n)